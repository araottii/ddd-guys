# DDD野郎勉強会4回目

- location: 渋谷
- atendees: kozzy, makocchi, arashi

## ToC

- recap for "DIP"
  - 依存性逆転の法則
    - interfaceを内側に定義する
      - interfaceはドメインレベルに定義(ケースによってはアプリケーションレイヤーに設置することもあります(詳細は次回以降でレクチャーします))
      - 実態(データベースや、実際にデータを取得する部分)の実装はインフラストラクチャレイヤーに実装する
  - 従来の歴史的な手法だと、実質的に技術的要素の可否によって、ビジネス要件が決められてしまうことが多かった(構造上そうならざるを得ない)
    - 上位の層は下位の層に依存する. e.g: ドメイン層はインフラ層に依存する
  - ビジネスユースケース(interface)が先に定義されてソレに対して技術が依存するという関係に切り替えるのが目的
    - 技術的詳細の抽象化の方法とも言える
    - 言い換えれば、ビジネスユースケースが技術詳細を決定づける
    - 本質的には、サービス開始、運用まで適切なcloud, DB, 各種コンポーネントを決めるのは難しい
      - e.g: 実際に運用してみたらリレーショナルデータベースよりもNoSQLの方がよかった, データベース製品のライセンス料が急に上がったので切り替えたい, より使いやすいライブラリを発見した, etc.
- 本日お題: DIPおかわり
  - Userを生成する際のID生成をDIPを使って切り離してください
- Domain Service: ドメインサービス
  - ドメイン自体のふるまいを定義する
  - 基本的には極力ドメインオブジェクト自体に振る舞いをもたせる
  - **どうしても技術的、ビジネス的な表現的に無理があるときにだけ、サービスとして切り出す**
  - 最後の最後でしか使わない
  - 乱用すると、いろんな場所でサービスを呼び出さないといけなくなるし、何より、ロジック自体が汎用化して意味がなくなる
    - さらにドメインオブジェクトから振る舞いがなくなって(サンプルコードの例だとUser.ChangeNameのような)getter, setterだけになってしまう
- CommandオブジェクトとDTO
  - DTO: data transfer object
    - より外側のレイヤーにデータを渡すためのオブジェクト
    - 通常、プリミティブ型のみで構成される
    - constructorにプリミティブ型を受け取って、getterのみにして副作用がないことを担保するという手法もある
      - 自分は直接structを作って返したりしてます
  - Commandオブジェクトにはダブルディスパッチするとメソッド変更の影響範囲を少なくすることができる
    - 外側からの入力を内側への入力に変換する
    - 通常、プリミティブ型のみで構成される
    - アプリケーションサービスの引数をCommandオブジェクトのみにしておくとメソッドシグネチャの変更に耐えやすくなる
- Q1. `User.UserName().FullName()` vs `User.FullName()`
  - 実際のところどっちでもいいですｗ
  - 手法としては、FullNameメソッドがどこで呼び出されるかに依存します。ドメインレベルでは `User.Name()`にとどめておいて、FullNameがほしいのがUI(ビューレイヤー)でアレば、DTOのメソッドにダブルディスパッチしておくべきです
- Q2. 値渡し vs 参照渡し
  - 正直なところでいうとどっちでもいいですｗ
  - ただ、EntityにValueObjectを指定する場合は、それがより不変性があることを表現するためにポインタを指定するの、いいと思います
  - 同様に関数が副作用がないことを保証するためにメソッドのレシーバーを値指定するのもいいと思います
- Q3. お題の`IdProvider`のinterfaceはどのディレクトリに置くべきか
  - 答えから先に書くと`domain/model/user/id_provider.go`のようにuser package配下に置くべき
  - もちろん`domain/model/id/id_provider.go`のようにinterfaceを共通化させることもできるが、基本的に*UserのIdを生成するもの*であって、共通的なIdを生成するものではないので、`domain/model/user/`配下においておくのがよさそう
  - ただ技術詳細としてのid生成クラスはinterfaceさえ満たせば使いまわせるので、今の段階では使い回す
    - 将来的に例えば、debuggingの際の可読性をあげるために`user-UUIDV4-unixtimestamp`みたいな形になれば、実態の実装を分けてあげればいい(もしくはprefix, suffixをドメインルールと考えるなら、中身のidを受け取って、prefix, suffixを付け足すような処理をUserIdのconstructorに書けばいい)
